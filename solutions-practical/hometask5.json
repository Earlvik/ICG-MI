{
  "version": 1,
  "title": "Untitled",
  "description": "",
  "programs": [
    {
      "version": 1,
      "name": "Default",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 mirror;\nuniform mat4 translate;\nuniform mat4 perspective;\nuniform mat4 scale;\nuniform mat4 center;\nuniform float v_Color;\nvarying float f_Color;\n\nvoid main() {\n    mat4 frustum_projection = center * scale * perspective * translate * mirror;\n    gl_Position = projection * modelview * frustum_projection * vec4(v_Position, 1);\n    f_Color = v_Color;\n}",
      "fragment": "#version 100\n\nprecision mediump float;\nvarying float f_Color;\n\nvoid main() {\n    if (f_Color == 1.0) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1);\n    } else if (f_Color == 2.0) {\n        gl_FragColor = vec4(0.0, 1.0, 0.0, 1);\n    } else if (f_Color == 3.0) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1);\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1);\n    }\n}",
      "isDefault": true
    }
  ],
  "javascript": "var debug = true;\n\nfunction dg(v) {\n    if(debug) {\n        debug = false;\n        alert(v);\n    }\n}\n\nfunction ui(c) {\n    var ui = c.ui;\n    // add left hand side grid\n    ui.add(ui.grid({\n        children: [\n            ui.label({ value: 'First step (Mirror):', title: 'Mirror step' }),\n            ui.onoff({bind: [this, 'step1']}),\n            ui.label({ value: 'Second step (Translation):', title: 'Translation step' }),\n            ui.onoff({bind: [this, 'step2']}),\n            ui.label({ value: 'Third step (Perspective):', title: 'Perspective step' }),\n            ui.onoff({bind: [this, 'step3']}),\n            ui.label({ value: 'Fourth step (Scale):', title: 'Scaling step' }),\n            ui.onoff({bind: [this, 'step4']}),\n            ui.label({ value: 'Fifth step (Center):', title: 'Centering step' }),\n            ui.onoff({bind: [this, 'step5']}),\n\n            ui.label({ value: 'Near distance:', title: 'Near distance' }),\n            ui.slider({\n                bind: [this, 'near'],\n                min: 0.0,\n                max: 10.0\n            }),\n            ui.label({ value: 'Far distance:', title: 'Far distance' }),\n            ui.slider({\n                bind: [this, 'far'],\n                min: 0.0,\n                max: 10\n            }),\n            ui.label({ value: 'Aspect ratio:', title: 'Aspect' }),\n            ui.slider({\n                bind: [this, 'aspect'],\n                min: 0.33,\n                max: 3\n            }),\n            ui.label({ value: 'Field of view:', title: 'Fov' }),\n            ui.slider({\n                bind: [this, 'fov'],\n                min: 0.0,\n                max: 90.0\n            }),\n        ]\n    }), { left: 10, bottom: 6 });\n}\n\nfunction init(c) {\n\n    this.near = 1.0;\n    this.far = 3.0;\n    this.aspect = 1.5;\n    this.fov = 45.0;\n\n    this.step1 = false;\n    this.step2 = false;\n    this.step3 = false;\n    this.step4 = false;\n    this.step5 = false;\n\n    c.gl.clearColor(0.5, 0.5, 0.5, 1.0);\n            this.cube = {};\n            var vertices = getCube(1);\n            this.cube.color = 3.0;\n            this.cube.length = vertices.length;\n            cubeVertexPositionBuffer = c.gl.createBuffer();\n            c.gl.bindBuffer(c.gl.ARRAY_BUFFER, cubeVertexPositionBuffer);\n            c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(vertices), c.gl.STATIC_DRAW);\n            this.cube.buffer = cubeVertexPositionBuffer;\n    ui.call(this, c);\n}\n\nfunction getCube(size) {\n    return [\n        0, size, 0,\n        size, size, 0,\n        size, 0, 0,\n        0, 0, 0,\n        0, size, 0,\n        0, size, size,\n        size, size, size,\n        size, size, 0,\n        size, size, size,\n        size, 0, size,\n        size, 0, 0,\n        size, 0 ,size,\n        0, 0, size,\n        0, 0, 0,\n        0, 0, size,\n        0, size, size,\n    ]\n}\n\nfunction getFrustum(near, far, aspect, fov) {\n    var camX = 0.0;\n    var camY = 0.0;\n    var camZ = 0.0;\n    var fovR = fov * Math.PI/180.0;\n    var nearH = 2 * Math.tan(fovR / 2.0) * near;\n    var farH = 2 * Math.tan(fovR / 2.0) * far;\n    var nearW = nearH * aspect;\n    var farW = farH * aspect;\n    var nt = camY + nearH/2.0;\n    var nb = camY - nearH/2.0;\n    var nl = camX - nearW/2.0;\n    var nr = camX + nearW/2.0;\n\n    var ft = camY + farH/2.0;\n    var fb = camY - farH/2.0;\n    var fl = camX - farW/2.0;\n    var fr = camX + farW/2.0;\n\n    return vertices = [\n        nl,  nt,  near,\n        nr, nt,  near,\n        nr, nb, near,\n        nl, nb, near,\n        nl,  nt,  near,\n        fl, ft, far,\n        fr, ft, far,\n        nr, nt,  near,\n        fr, ft, far,\n        fr, fb, far,\n        nr, nb, near,\n        fr, fb, far,\n        fl, fb, far,\n        nl, nb, near,\n        fl, fb, far,\n        fl, ft, far\n    ];\n}\n\nfunction render(c) {\n\n\n           if (this.near > this.far) {\n        this.near += this.far;\n        this.far = this.near - this.far;\n        this.near = this.near - this.far;\n    }\n\n    var vertices = getFrustum(this.near, this.far, this.aspect, this.fov);\n\n    frustumVertexPositionBuffer = c.gl.createBuffer();\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, frustumVertexPositionBuffer);\n    c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(vertices), c.gl.STATIC_DRAW);\n    this.frustum = frustumVertexPositionBuffer;\n    this.frustum.length = vertices.length;\n    this.frustum.color = 10.0;\n\n    // set 'Default' as current shader program\n    c.gl.useProgram(c.programs.Default.program);\n\n    // get locations of uniforms/attributes and enable the latter\n    var prLocation = c.gl.getUniformLocation(c.programs.Default.program, \"projection\");\n    var mvLocation = c.gl.getUniformLocation(c.programs.Default.program, \"modelview\");\n    var posLocation = c.gl.getAttribLocation(c.programs.Default.program, \"v_Position\");\n\n    var mrLocation = c.gl.getUniformLocation(c.programs.Default.program, \"mirror\");\n    var trLocation = c.gl.getUniformLocation(c.programs.Default.program, \"translate\");\n    var perLocation = c.gl.getUniformLocation(c.programs.Default.program, \"perspective\");\n    var scLocation = c.gl.getUniformLocation(c.programs.Default.program, \"scale\");\n    var cnLocation = c.gl.getUniformLocation(c.programs.Default.program, \"center\");\n\n    var colLocation = c.gl.getUniformLocation(c.programs.Default.program, \"v_Color\");\n    c.gl.enableVertexAttribArray(colLocation);\n\n    c.gl.enableVertexAttribArray(posLocation);\n\n    // get canvas dimensions\n    var w = c.gl.canvas.clientWidth;\n    var h = c.gl.canvas.clientHeight;\n\n    var mr = c.math.mat4.create();\n    var tr = c.math.mat4.create();\n    var per = c.math.mat4.create();\n    var sc = c.math.mat4.create();\n    var cn = c.math.mat4.create();\n\n    c.math.mat4.identity(mr);\n    if (this.step1) {\n        mr[10] = -1;\n    }\n    c.gl.uniformMatrix4fv(mrLocation, false, mr);\n\n    c.math.mat4.identity(tr);\n    if (this.step2) {\n        tr[11] = -this.near;\n    }\n    c.gl.uniformMatrix4fv(trLocation, false, tr);\n\n    c.math.mat4.identity(per);\n    if (this.step3) {\n        per[14] = 1/this.near;\n    }\n    c.gl.uniformMatrix4fv(perLocation, false, per);\n\n    c.math.mat4.identity(sc);\n    if (this.step4) {\n        var camX = 0.0;\n        var camY = 0.0;\n        var camZ = 0.0;\n        var fovR = this.fov * Math.PI/180.0;\n        var nearH = 2 * Math.tan(fovR / 2.0) * this.near;\n        var nearW = nearH * this.aspect;\n        var nt = camY + nearH/2.0;\n        var nb = camY - nearH/2.0;\n        var nl = camX - nearW/2.0;\n        var nr = camX + nearW/2.0;\n        sc[0] = 2.0 / (nr - nl);\n        sc[5] = 2.0 / (nt - nb);\n        sc[10] = 2.0 * this.far / ((this.far - this.near) * this.near);\n    }\n    c.gl.uniformMatrix4fv(scLocation, false, sc);\n\n    c.math.mat4.identity(cn);\n    if (this.step5) {\n        cn[11] = -1;\n    }\n    c.gl.uniformMatrix4fv(cnLocation, false, cn);\n\n    // init projection matrix\n    var pr = c.math.mat4.create();\n    //c.math.mat4.perspective(pr, 90 * Math.PI / 180.0, w / h, 0.1, 100.0);\n    c.math.mat4.ortho(pr, -5.0, 5.0, -5.0, 5.0, 0.1, 100);\n    c.gl.uniformMatrix4fv(prLocation, false, pr);\n\n    // init modelview matrix\n    var mv = c.math.mat4.create();\n    c.math.mat4.identity(mv);\n\n    // clear framebuffer\n    c.gl.viewport(0, 0, w, h);\n    c.gl.clear(c.gl.COLOR_BUFFER_BIT);\n\n    // render frustum\n    c.math.mat4.translate(mv, mv, [0.0, 0.0, -9.0]);\n    c.math.mat4.rotateY(mv, mv, Math.PI/4);\n    c.gl.uniformMatrix4fv(mvLocation, false, mv);\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.frustum);\n    c.gl.vertexAttribPointer(posLocation, 3.0, c.gl.FLOAT, false, 0, 0);\n    c.gl.uniform1f(colLocation, this.frustum.color);\n    c.gl.drawArrays(c.gl.LINE_STRIP, 0, this.frustum.length/3.0);\n\n    //render cube\n    c.math.mat4.translate(mv, mv, [0.0, -0.5, 2.0]);\n    //c.math.mat4.rotateY(mv, mv, Math.PI/4);\n    c.gl.uniformMatrix4fv(mvLocation, false, mv);\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.cube.buffer);\n    c.gl.vertexAttribPointer(posLocation, 3.0, c.gl.FLOAT, false, 0, 0);\n    c.gl.uniform1f(colLocation, this.cube.color);\n    c.gl.drawArrays(c.gl.LINE_STRIP, 0, this.cube.length/3.0);\n}",
  "creationTime": "2016-12-04T18:30:10.220Z",
  "authors": []
}